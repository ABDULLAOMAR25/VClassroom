<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Video Classroom</title>
  <script src="https://unpkg.com/@livekit/client/dist/livekit-client.min.js"></script>
  <style>
    * {
      box-sizing: border-box;
      margin: 0; padding: 0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    body {
      display: flex;
      flex-direction: column;
      height: 100vh;
      background-color: #f4f6f9;
      padding: 20px;
      color: #2c3e50;
    }
    header {
      text-align: center;
      font-size: 24px;
      margin-bottom: 20px;
      font-weight: bold;
    }
    #container {
      flex: 1;
      display: flex;
      gap: 20px;
    }
    #left-panel {
      flex: 3;
      display: flex;
      flex-direction: column;
    }
    #video-container {
      display: flex;
      justify-content: center;
      gap: 20px;
      flex-wrap: wrap;
      margin-bottom: 20px;
      flex: 1;
    }
    video {
      width: 100%;
      max-width: 480px;
      height: auto;
      border-radius: 12px;
      background-color: #000;
      box-shadow: 0 4px 10px rgba(0,0,0,0.1);
    }
    #controls {
      display: flex;
      justify-content: center;
      gap: 15px;
      margin-bottom: 10px;
    }
    #controls button {
      font-size: 16px;
      padding: 10px 25px;
      border: none;
      border-radius: 8px;
      background-color: #1abc9c;
      color: white;
      cursor: pointer;
      transition: background-color 0.3s ease;
    }
    #controls button:hover:not(:disabled) {
      background-color: #16a085;
    }
    #controls button:disabled {
      background-color: #ccc;
      cursor: not-allowed;
    }
    #right-panel {
      flex: 1;
      display: flex;
      flex-direction: column;
      background: #fff;
      border-radius: 10px;
      box-shadow: 0 0 10px rgb(0 0 0 / 0.1);
      padding: 15px;
      height: 100%;
    }
    #participants {
      flex: 1;
      overflow-y: auto;
      margin-bottom: 10px;
      border-bottom: 1px solid #ccc;
    }
    #participants strong {
      display: block;
      margin-bottom: 10px;
      font-weight: 600;
      font-size: 18px;
      color: #16a085;
    }
    #participant-list {
      list-style: none;
      padding-left: 0;
    }
    #participant-list li {
      padding: 5px 0;
      border-bottom: 1px solid #eee;
    }
    #chat {
      flex: 2;
      display: flex;
      flex-direction: column;
      height: 100%;
    }
    #messages {
      flex: 1;
      overflow-y: auto;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 8px;
      background-color: #fafafa;
      margin-bottom: 10px;
      font-size: 14px;
      color: #333;
    }
    #chat-input {
      display: flex;
      gap: 10px;
    }
    #chat-input input {
      flex: 1;
      padding: 10px;
      font-size: 14px;
      border: 1px solid #ccc;
      border-radius: 5px;
    }
    #chat-input button {
      padding: 10px 20px;
      background-color: #16a085;
      border: none;
      border-radius: 5px;
      color: white;
      font-size: 14px;
      cursor: pointer;
      transition: background-color 0.3s ease;
    }
    #chat-input button:hover {
      background-color: #1abc9c;
    }
  </style>
</head>
<body>

<header>Live Class Session: {{ session.class_name }}</header>

<div id="container">
  <div id="left-panel">
    <div id="video-container">
      <video id="local-video" autoplay muted playsinline></video>
      <video id="remote-video" autoplay playsinline></video>
    </div>
    <div id="controls">
      <button id="camera-btn">üì∑ Camera</button>
      <button id="mic-btn" disabled>üé§ Mic</button>
      <button id="record-btn" disabled>‚è∫Ô∏è Record</button>
      <button id="stop-btn" disabled>üõë Stop</button>
      <button id="raise-hand-btn">‚úã Raise Hand</button>
    </div>
  </div>

  <div id="right-panel">
    <div id="participants">
      <strong>Participants</strong>
      <ul id="participant-list"></ul>
    </div>
    <div id="chat">
      <div id="messages"></div>
      <div id="chat-input">
        <input type="text" id="messageBox" placeholder="Type your message..." />
        <button id="send-btn">Send</button>
      </div>
    </div>
  </div>
</div>

<footer>&copy; 2025 Technologist TV | All Rights Reserved</footer>

<script>
  const roomName = "classroom_{{ session.id }}";
  const identity = prompt("Enter your name:") || "Guest";
  let room;
  let localTracks = [];
  let cameraOn = false;
  let micOn = false;
  let mediaRecorder;
  let recordedChunks = [];
  let recordingStream;

  // UI elements
  const cameraBtn = document.getElementById("camera-btn");
  const micBtn = document.getElementById("mic-btn");
  const recordBtn = document.getElementById("record-btn");
  const stopBtn = document.getElementById("stop-btn");
  const raiseHandBtn = document.getElementById("raise-hand-btn");
  const participantList = document.getElementById("participant-list");
  const messagesDiv = document.getElementById("messages");
  const messageBox = document.getElementById("messageBox");
  const sendBtn = document.getElementById("send-btn");
  const localVideo = document.getElementById("local-video");

  // Connect to LiveKit room and set up event handlers
  fetch('/get_token', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ identity, room: roomName })
  })
  .then(res => res.json())
  .then(async ({ token, url }) => {
    room = new Livekit.Room();

    room.on("trackSubscribed", (track, publication, participant) => {
      if (track.kind === "video") {
        track.attach(document.getElementById("remote-video"));
      }
    });

    room.on("participantConnected", participant => {
      addParticipant(participant);
      addMessage(`${participant.identity} joined the room.`);
    });

    room.on("participantDisconnected", participant => {
      removeParticipant(participant);
      addMessage(`${participant.identity} left the room.`);
    });

    await room.connect(url, token);

    // Add existing participants to list
    room.participants.forEach(addParticipant);
  });

  function addParticipant(participant) {
    const li = document.createElement("li");
    li.textContent = participant.identity;
    li.id = participant.sid;
    participantList.appendChild(li);
  }
  function removeParticipant(participant) {
    const li = document.getElementById(participant.sid);
    if (li) li.remove();
  }

  // Chat message management
  function addMessage(text) {
    const div = document.createElement("div");
    div.textContent = text;
    messagesDiv.appendChild(div);
    messagesDiv.scrollTop = messagesDiv.scrollHeight;
  }

  // Simple message broadcasting via DataTracks (LiveKit)
  let dataChannel;

  async function setupDataChannel() {
    if (!room) return;
    dataChannel = await room.localParticipant.publishData();
    room.on("dataReceived", (payload, participant) => {
      const message = new TextDecoder().decode(payload);
      addMessage(`${participant.identity}: ${message}`);
    });
  }

  // Start camera (on button click)
  async function startCamera() {
    if(cameraOn) {
      // Turn camera off
      const videoTrack = localTracks.find(t => t.kind === 'video');
      if(videoTrack) {
        videoTrack.stop();
        room.localParticipant.unpublishTrack(videoTrack);
      }
      localTracks = localTracks.filter(t => t.kind !== 'video');
      localVideo.srcObject = null;
      cameraOn = false;
      micBtn.disabled = true;
      micBtn.innerText = "üé§ Mic";
      recordBtn.disabled = true;
      cameraBtn.innerText = "üì∑ Camera";
      return;
    }

    try {
      const tracks = await Livekit.createLocalTracks({ video: true });
      for (const track of tracks) {
        await room.localParticipant.publishTrack(track);
        track.attach(localVideo);
        localTracks.push(track);
      }
      cameraOn = true;
      micBtn.disabled = false;
      micBtn.innerText = "üé§ Mic On";
      recordBtn.disabled = false;
      cameraBtn.innerText = "üö´ Camera Off";
    } catch (err) {
      alert("Could not start camera: " + err.message);
    }
  }

  // Toggle mic on/off
  async function toggleMic() {
    if (!cameraOn) return alert("Turn on the camera first!");

    const audioTrack = localTracks.find(t => t.kind === 'audio');
    if (!audioTrack) {
      // First time get mic track
      try {
        const tracks = await Livekit.createLocalTracks({ audio: true });
        for (const t of tracks) {
          await room.localParticipant.publishTrack(t);
          localTracks.push(t);
        }
        micOn = true;
        micBtn.innerText = "üîá Mic Off";
      } catch (e) {
        alert("Could not access mic: " + e.message);
      }
      return;
    }
    if (audioTrack.isEnabled) {
      audioTrack.disable();
      micBtn.innerText = "üîá Mic Off";
      micOn = false;
    } else {
      audioTrack.enable();
      micBtn.innerText = "üé§ Mic On";
      micOn = true;
    }
  }

  // Start recording camera+mic stream
  function startRecording() {
    if(!cameraOn) {
      return alert("Turn on the camera before recording!");
    }
    if(!micOn) {
      return alert("Turn on the mic before recording!");
    }
    const videoTrack = localTracks.find(t => t.kind === 'video');
    const audioTrack = localTracks.find(t => t.kind === 'audio');

    if (!videoTrack || !audioTrack) {
      return alert("Camera and Mic must be active to record!");
    }

    recordingStream = new MediaStream([
      videoTrack.mediaStreamTrack,
      audioTrack.mediaStreamTrack
    ]);

    recordedChunks = [];
    mediaRecorder = new MediaRecorder(recordingStream);

    mediaRecorder.ondataavailable = e => {
      if(e.data.size > 0) recordedChunks.push(e.data);
    };

    mediaRecorder.onstop = () => {
      const blob = new Blob(recordedChunks, {type: 'video/webm'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `recording_${Date.now()}.webm`;
      a.click();
      URL.revokeObjectURL(url);
    };

    mediaRecorder.start();
    recordBtn.disabled = true;
    stopBtn.disabled = false;
  }

  // Stop recording
  function stopRecording() {
    if(mediaRecorder && mediaRecorder.state !== 'inactive') {
      mediaRecorder.stop();
      recordBtn.disabled = false;
      stopBtn.disabled = true;
    }
  }

  // Raise hand broadcast message
  function raiseHand() {
    if (!dataChannel) {
      alert("Data channel not ready yet.");
      return;
    }
    const message = `${identity} raised their hand ‚úã`;
    dataChannel.send(new TextEncoder().encode(message));
    addMessage(message);
  }

  // Send chat message
  function sendMessage() {
    if (!dataChannel) {
      alert("Data channel not ready yet.");
      return;
    }
    const text = messageBox.value.trim();
    if(!text) return;
    dataChannel.send(new TextEncoder().encode(text));
    addMessage(`${identity}: ${text}`);
    messageBox.value = "";
  }

  cameraBtn.addEventListener('click', startCamera);
  micBtn.addEventListener('click', toggleMic);
  recordBtn.addEventListener('click', startRecording);
  stopBtn.addEventListener('click', stopRecording);
  raiseHandBtn.addEventListener('click', raiseHand);
  sendBtn.addEventListener('click', sendMessage);

  // Setup data channel after connecting
  const waitForRoom = setInterval(() => {
    if(room && room.localParticipant) {
      clearInterval(waitForRoom);
      setupDataChannel();
    }
  }, 500);

  async function setupDataChannel() {
    if (!room) return;
    try {
      dataChannel = await room.localParticipant.publishData();
      room.on("dataReceived", (payload, participant) => {
        const message = new TextDecoder().decode(payload);
        addMessage(`${participant.identity}: ${message}`);
      });
    } catch(e) {
      console.error("Failed to setup data channel", e);
    }
  }
</script>

</body>
</html>
